"use strict";(globalThis.webpackChunkaubury_blog=globalThis.webpackChunkaubury_blog||[]).push([[1341],{6002(e,t,s){s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});var n=s(4899),a=s(4848),r=s(8453);const i={slug:"evm-is-a-storage-machine",title:"The EVM is a storage machine",authors:"aubury",tags:["evm","gas","opcodes","ethereum"],date:new Date("2026-02-22T00:00:00.000Z")},o=void 0,c={authorsImageUrls:[void 0]},l=[{value:"The breakdown",id:"the-breakdown",level:2},{value:"SLOAD: cold vs warm",id:"sload-cold-vs-warm",level:2},{value:"SSTORE is more complicated",id:"sstore-is-more-complicated",level:2},{value:"Things that stood out",id:"things-that-stood-out",level:2},{value:"Data",id:"data",level:2}];function d(e){const t={br:"br",code:"code",em:"em",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:'The "Ethereum Virtual Machine" sounds like a computation engine. In practice, looking at 101 blocks of opcode execution data, it spends most of its time doing something much more mundane: reading and writing state.'}),"\n",(0,a.jsxs)(t.p,{children:["SSTORE and SLOAD together account for ",(0,a.jsx)(t.strong,{children:"60.7% of all gas consumed"})," on mainnet. Every other opcode \u2014 arithmetic, hashing, control flow, cross-contract calls \u2014 splits the remaining 39.3%."]}),"\n",(0,a.jsx)(t.h2,{id:"the-breakdown",children:"The breakdown"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Category"}),(0,a.jsx)(t.th,{children:"Executions"}),(0,a.jsx)(t.th,{children:"Gas"}),(0,a.jsx)(t.th,{children:"Share"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Storage (SSTORE, SLOAD)"}),(0,a.jsx)(t.td,{children:"2,429,785"}),(0,a.jsx)(t.td,{children:"1,598,536,382"}),(0,a.jsx)(t.td,{children:"60.7%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Stack & memory"}),(0,a.jsx)(t.td,{children:"109,827,251"}),(0,a.jsx)(t.td,{children:"321,904,043"}),(0,a.jsx)(t.td,{children:"12.2%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Call-related"}),(0,a.jsx)(t.td,{children:"185,535"}),(0,a.jsx)(t.td,{children:"221,142,755"}),(0,a.jsx)(t.td,{children:"8.4%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Events (LOGn)"}),(0,a.jsx)(t.td,{children:"91,213"}),(0,a.jsx)(t.td,{children:"167,857,156"}),(0,a.jsx)(t.td,{children:"6.4%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Control flow"}),(0,a.jsx)(t.td,{children:"29,963,966"}),(0,a.jsx)(t.td,{children:"156,562,350"}),(0,a.jsx)(t.td,{children:"5.9%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Arithmetic"}),(0,a.jsx)(t.td,{children:"28,977,777"}),(0,a.jsx)(t.td,{children:"95,085,735"}),(0,a.jsx)(t.td,{children:"3.6%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Hashing (KECCAK256)"}),(0,a.jsx)(t.td,{children:"1,155,611"}),(0,a.jsx)(t.td,{children:"47,471,328"}),(0,a.jsx)(t.td,{children:"1.8%"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Contract creation"}),(0,a.jsx)(t.td,{children:"99"}),(0,a.jsx)(t.td,{children:"11,421,560"}),(0,a.jsx)(t.td,{children:"0.4%"})]})]})]}),"\n",(0,a.jsx)(t.p,{children:"The arithmetic row is the one that surprised me. 28 million arithmetic opcode executions consuming 3.6% of gas. Meanwhile 2.4 million storage operations consume 60.7%. The per-operation cost ratio is roughly 3 gas for arithmetic vs 311\u20133,688 gas for storage. State access is 100x\u20131000x more expensive than computation, which is why the totals look the way they do."}),"\n",(0,a.jsx)(t.h2,{id:"sload-cold-vs-warm",children:"SLOAD: cold vs warm"}),"\n",(0,a.jsx)(t.p,{children:'SLOAD costs aren\'t fixed. Under EIP-2929, the first access to a storage slot in a transaction ("cold") costs 2,100 gas. Every subsequent access to the same slot ("warm") costs 100 gas \u2014 a 21x difference.'}),"\n",(0,a.jsx)(t.p,{children:"In this dataset: 10.55% of SLOADs are cold. The expected gas checks out exactly:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Access type"}),(0,a.jsx)(t.th,{children:"Count"}),(0,a.jsx)(t.th,{children:"Gas/access"}),(0,a.jsx)(t.th,{children:"Total gas"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Cold (first access)"}),(0,a.jsx)(t.td,{children:"225,818"}),(0,a.jsx)(t.td,{children:"2,100"}),(0,a.jsx)(t.td,{children:"474,217,800"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Warm (cached)"}),(0,a.jsx)(t.td,{children:"1,915,044"}),(0,a.jsx)(t.td,{children:"100"}),(0,a.jsx)(t.td,{children:"191,504,400"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.strong,{children:"Total"})}),(0,a.jsx)(t.td,{children:"2,140,862"}),(0,a.jsx)(t.td,{children:"311 avg"}),(0,a.jsx)(t.td,{children:"665,722,200"})]})]})]}),"\n",(0,a.jsx)(t.p,{children:"The 311 gas average follows directly from the cold/warm split. If contracts accessed the same slots more often within transactions, this average would drop. If they always hit new slots, it would be 2,100. The 10.55% cold rate tells you something about how contracts are written: most SLOADs are reads of state that was already touched earlier in the transaction."}),"\n",(0,a.jsx)(t.h2,{id:"sstore-is-more-complicated",children:"SSTORE is more complicated"}),"\n",(0,a.jsx)(t.p,{children:'SSTORE averages 3,688 gas \u2014 well below the 20,000 gas "new slot" cost that gets quoted in gas optimisation articles. That\'s because most SSTOREs aren\'t writing to fresh storage. EIP-2200 introduced net-change semantics: writing to a slot that already has a value costs 2,900 gas (the "dirty write" case). Only 2.75% of SSTOREs are cold writes.'}),"\n",(0,a.jsx)(t.p,{children:"The practical implication: if you're worried about storage costs, the expensive case is almost always the first write to a new slot. After that, updates are roughly 2,900 gas."}),"\n",(0,a.jsx)(t.h2,{id:"things-that-stood-out",children:"Things that stood out"}),"\n",(0,a.jsxs)(t.p,{children:["LOG3 is the fourth-largest gas consumer at 5.14%. LOG3 is an event emission with three indexed topics \u2014 the exact signature of ERC-20 ",(0,a.jsx)(t.code,{children:"Transfer(address indexed from, address indexed to, uint256 value)"}),". So the fourth most expensive thing happening on mainnet, measured in gas, is token transfers emitting their Transfer event."]}),"\n",(0,a.jsxs)(t.p,{children:["CREATE2 executed 89 times across 101 blocks, averaging 118,694 gas per call. That's roughly one CREATE2 per block, and each one costs as much as deploying a small contract. That's expected \u2014 CREATE2 ",(0,a.jsx)(t.em,{children:"is"})," contract deployment \u2014 but the average being that high suggests these are non-trivial deployments."]}),"\n",(0,a.jsx)(t.p,{children:"SELFDESTRUCT: still there. 1,025 executions at 5,020 gas each. Given EIP-6780 (Cancun) limiting SELFDESTRUCT to only clear a contract in the same transaction it was created, these are likely legacy patterns. SELFDESTRUCT's days are numbered."}),"\n",(0,a.jsx)(t.p,{children:"TLOAD appears at exactly 100 gas per execution \u2014 EIP-1153 transient storage from Cancun, working as specified. Small numbers for now (19,754 executions), but the price is right for contracts that need intra-transaction state without paying permanent storage costs."}),"\n",(0,a.jsx)(t.h2,{id:"data",children:"Data"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Source:"})," ",(0,a.jsx)(t.code,{children:"canonical_execution_transaction_structlog_agg"}),(0,a.jsx)(t.br,{}),"\n",(0,a.jsx)(t.strong,{children:"Blocks:"})," 24,511,499 \u2013 24,511,599 (101 blocks, mainnet)"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT \n    operation,\n    sum(opcode_count) as executions,\n    sum(gas) as total_gas,\n    round(sum(gas) / sum(opcode_count), 1) as avg_gas,\n    round(sum(gas) / total_sum * 100, 2) as gas_share_pct,\n    sum(cold_access_count) as cold_accesses\nFROM canonical_execution_transaction_structlog_agg\nWHERE meta_network_name = 'mainnet'\n  AND operation != ''\n  AND block_number BETWEEN 24511499 AND 24511599\nGROUP BY operation\nORDER BY total_gas DESC\nLIMIT 30\n"})}),"\n",(0,a.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,t,s){s.d(t,{R:()=>i,x:()=>o});var n=s(6540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}},4899(e){e.exports=JSON.parse('{"permalink":"/blog/evm-is-a-storage-machine","source":"@site/blog/2026-02-22-evm-is-a-storage-machine.md","title":"The EVM is a storage machine","description":"The \\"Ethereum Virtual Machine\\" sounds like a computation engine. In practice, looking at 101 blocks of opcode execution data, it spends most of its time doing something much more mundane: reading and writing state.","date":"2026-02-22T00:00:00.000Z","tags":[{"inline":true,"label":"evm","permalink":"/blog/tags/evm"},{"inline":true,"label":"gas","permalink":"/blog/tags/gas"},{"inline":true,"label":"opcodes","permalink":"/blog/tags/opcodes"},{"inline":true,"label":"ethereum","permalink":"/blog/tags/ethereum"}],"readingTime":3.19,"hasTruncateMarker":true,"authors":[{"name":"Aubury Essentian","title":"Ethereum Research","url":"https://github.com/AuburyEssentian","imageURL":"/img/avatar.png","key":"aubury","page":null}],"frontMatter":{"slug":"evm-is-a-storage-machine","title":"The EVM is a storage machine","authors":"aubury","tags":["evm","gas","opcodes","ethereum"],"date":"2026-02-22T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Ethereum Block Timing","permalink":"/blog/ethereum-block-timing"},"nextItem":{"title":"MEV Bot Censorship on Ethereum","permalink":"/blog/mev-bot-censorship"}}')}}]);