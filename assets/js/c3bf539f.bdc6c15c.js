"use strict";(globalThis.webpackChunkaubury_blog=globalThis.webpackChunkaubury_blog||[]).push([[8492],{7513(e,t,n){n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var s=n(1742),i=n(4848),r=n(8453);const l={slug:"nethermind-blob-blindspot",title:"The Blob Blindspot: Half of Nethermind Validators Still Can't Serve Blobs",authors:["aubury"],tags:["ethereum","execution-clients","blobs","pectra","nethermind"]},o=void 0,a={authorsImageUrls:[void 0]},d=[{value:"What engine_getBlobsV2 does",id:"what-engine_getblobsv2-does",level:2},{value:"Nethermind: stuck at 44% since day one",id:"nethermind-stuck-at-44-since-day-one",level:2},{value:"The culprit: one specific version",id:"the-culprit-one-specific-version",level:2},{value:"Builders know \u2014 validators don&#39;t",id:"builders-know--validators-dont",level:2},{value:"The practical cost",id:"the-practical-cost",level:2},{value:"What to do",id:"what-to-do",level:2}];function h(e){const t={code:"code",em:"em",h2:"h2",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"One month after Pectra went live, roughly 44% of all Nethermind validator nodes are rejecting a blob retrieval call that was introduced in that very fork. Every other major execution client has mostly fixed this. Nethermind hasn't moved."}),"\n",(0,i.jsx)(t.p,{children:"This is the data on what's happening, why it matters, and where the fault line sits."}),"\n",(0,i.jsx)(t.h2,{id:"what-engine_getblobsv2-does",children:"What engine_getBlobsV2 does"}),"\n",(0,i.jsxs)(t.p,{children:["Pectra (activated January 25, 2026) added a new Engine API call: ",(0,i.jsx)(t.code,{children:"engine_getBlobsV2"}),". The idea is simple \u2014 when a consensus client receives a new block containing blob commitments, it asks its execution client: ",(0,i.jsx)(t.em,{children:'"do you have these blobs in your local cache?"'})," The EL, which participates in the blob P2P network independently, should already have them. The CL can then verify blob availability without touching the P2P layer itself."]}),"\n",(0,i.jsx)(t.p,{children:'If the EL says "I don\'t have it" \u2014 or worse, "I don\'t support this call" \u2014 the CL has to fall back and fetch all blobs itself from peers. With typical blocks carrying 5\u20136 blobs (post-Pectra target), that\'s a non-trivial fallback.'}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"UNSUPPORTED"})," status code specifically means the EL doesn't implement the method at all. It returns in ~1 ms with zero blobs. That's not a cache miss \u2014 it's a blank stare."]}),"\n",(0,i.jsx)(t.h2,{id:"nethermind-stuck-at-44-since-day-one",children:"Nethermind: stuck at 44% since day one"}),"\n",(0,i.jsxs)(t.p,{children:["The ethpandaops infrastructure has been monitoring ",(0,i.jsx)(t.code,{children:"engine_getBlobsV2"})," calls since shortly after Pectra launched. The pattern for Nethermind validator (non-builder) nodes is stark."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Query: fct_engine_get_blobs_by_el_client\nFilter: node_class = '', mainnet, Jan 25 \u2013 Feb 25, 2026\nGroup: day, meta_execution_implementation, status\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Nethermind blob UNSUPPORTED rate vs other EL clients",src:n(1669).A+"",width:"1789",height:"870"})}),"\n",(0,i.jsxs)(t.p,{children:["On January 27 \u2014 the first full day of monitoring data \u2014 Nethermind regular validator nodes showed a ",(0,i.jsx)(t.strong,{children:"52% UNSUPPORTED rate"}),". One month later, it's still ",(0,i.jsx)(t.strong,{children:"41%"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Every other EL client has converged toward near-zero:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Reth"})," started at 7\u201314% and is now at ~1%"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"go-ethereum"})," dropped from ~16% to ~3%"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Erigon"})," declined from ~22% to ~3%"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Nethermind hasn't moved."}),"\n",(0,i.jsx)(t.h2,{id:"the-culprit-one-specific-version",children:"The culprit: one specific version"}),"\n",(0,i.jsxs)(t.p,{children:["Drilling into the raw ",(0,i.jsx)(t.code,{children:"execution_engine_get_blobs"})," table reveals the version breakdown clearly."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Query: execution_engine_get_blobs\nFilter: meta_execution_implementation = 'Nethermind', mainnet, 7d\nGroup: meta_execution_version_minor, status\n"})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Version"}),(0,i.jsx)(t.th,{children:"SUCCESS calls"}),(0,i.jsx)(t.th,{children:"UNSUPPORTED calls"}),(0,i.jsx)(t.th,{children:"UNSUPPORTED rate"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"v1.37.x"}),(0,i.jsx)(t.td,{children:"52,399"}),(0,i.jsx)(t.td,{children:"1,530"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"3%"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"v1.35.x"}),(0,i.jsx)(t.td,{children:"41,625"}),(0,i.jsx)(t.td,{children:"107,294"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"72%"})})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["Nethermind v1.37.x handles blob requests just fine. Nethermind ",(0,i.jsx)(t.strong,{children:"v1.35.2"})," \u2014 specifically the build tagged ",(0,i.jsx)(t.code,{children:"1.35.2+faa9b9e6"})," \u2014 is responsible for 107,000+ UNSUPPORTED responses in the past week alone. That single build accounts for the majority of Nethermind's blindspot."]}),"\n",(0,i.jsxs)(t.p,{children:["The version gap spans at least one minor release cycle. v1.35.x didn't ship ",(0,i.jsx)(t.code,{children:"engine_getBlobsV2"})," support; v1.37.x did. And a large cohort of validator operators hasn't crossed that boundary in the month since Pectra launched."]}),"\n",(0,i.jsx)(t.h2,{id:"builders-know--validators-dont",children:"Builders know \u2014 validators don't"}),"\n",(0,i.jsxs)(t.p,{children:["There's a telling split within Nethermind's own ecosystem. The same dataset, filtered by ",(0,i.jsx)(t.code,{children:"node_class"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Query: fct_engine_get_blobs_by_el_client\nFilter: mainnet, 7d, meta_execution_implementation = 'Nethermind'\nGroup: node_class, status\n"})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Node type"}),(0,i.jsx)(t.th,{children:"UNSUPPORTED rate"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["Validator nodes (",(0,i.jsx)(t.code,{children:"node_class = ''"}),")"]}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"44%"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["Block builder nodes (",(0,i.jsx)(t.code,{children:"node_class = 'eip7870-block-builder'"}),")"]}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"6%"})})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Builder operators \u2014 the teams running MEV infrastructure 24/7 \u2014 are almost entirely on v1.37.x. They update constantly because being on stale software costs them money."}),"\n",(0,i.jsx)(t.p,{children:"Validator operators don't have the same forcing function. Many are running solo stakers or smaller services on set-and-forget configurations. A 30-day version gap is normal for that population. The problem is that Pectra introduced a new requirement they don't know they're failing."}),"\n",(0,i.jsx)(t.h2,{id:"the-practical-cost",children:"The practical cost"}),"\n",(0,i.jsx)(t.p,{children:"When a CL is paired with a v1.35.2 Nethermind, every blob-bearing block triggers the following sequence:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["CL sends ",(0,i.jsx)(t.code,{children:"engine_getBlobsV2"})," \u2192 gets ",(0,i.jsx)(t.code,{children:"UNSUPPORTED"})," in 1 ms"]}),"\n",(0,i.jsx)(t.li,{children:"CL falls back to P2P blob fetching \u2014 independently requesting each blob hash from its gossip peers"}),"\n",(0,i.jsx)(t.li,{children:"If blobs are already propagated (usually true), the fetch completes in tens to hundreds of milliseconds"}),"\n",(0,i.jsx)(t.li,{children:"If the network is under load, fetches can take longer"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Most of the time this is a performance cost, not a correctness failure. The CL will eventually get the blobs. But timing matters in Ethereum PoS \u2014 attestations must be published within about 4 seconds of slot start, and block processing competes for that same window. Consistently slow blob resolution means consistently slower block processing, which means validators paired with v1.35.2 Nethermind are running slightly more exposed to attestation timing pressure."}),"\n",(0,i.jsx)(t.p,{children:"At scale, 44% of the Nethermind validator population is a meaningful fraction of the network. It's not catastrophic, but it's a quiet drag that's been running since day one of Pectra."}),"\n",(0,i.jsx)(t.h2,{id:"what-to-do",children:"What to do"}),"\n",(0,i.jsx)(t.p,{children:"If you're running Nethermind as your execution client, check your version:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'# Nethermind HTTP API\ncurl -s -X POST http://localhost:8545 \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}\'\n'})}),"\n",(0,i.jsxs)(t.p,{children:["If you see ",(0,i.jsx)(t.code,{children:"Nethermind/v1.35.x"}),", upgrade. The v1.37.x releases include ",(0,i.jsx)(t.code,{children:"engine_getBlobsV2"})," support and the UNSUPPORTED rate for those builds is ~3%."]}),"\n",(0,i.jsx)(t.p,{children:"The broader point: Pectra changed more than just blob limits. It added new Engine API surface that older EL versions simply don't implement. Validators who updated their node software before the fork might have been on a version that predated those additions. One month in, that's still showing up clearly in the data."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["Data source: ethpandaops xatu, ",(0,i.jsx)(t.code,{children:"execution_engine_get_blobs"})," table (raw) and ",(0,i.jsx)(t.code,{children:"mainnet.fct_engine_get_blobs_by_el_client"})," (CBT), mainnet, January 25 \u2013 February 25, 2026. Validator nodes only (",(0,i.jsx)(t.code,{children:"node_class = ''"}),"). Builder nodes excluded."]})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1669(e,t,n){n.d(t,{A:()=>s});const s=n.p+"assets/images/nethermind-blob-unsupported-f1aeb2ef97b1a5ba19686936d0fa9260.png"},8453(e,t,n){n.d(t,{R:()=>l,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function l(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:t},e.children)}},1742(e){e.exports=JSON.parse('{"permalink":"/blog/nethermind-blob-blindspot","source":"@site/blog/2026-02-26-nethermind-blob-blindspot.md","title":"The Blob Blindspot: Half of Nethermind Validators Still Can\'t Serve Blobs","description":"One month after Pectra went live, roughly 44% of all Nethermind validator nodes are rejecting a blob retrieval call that was introduced in that very fork. Every other major execution client has mostly fixed this. Nethermind hasn\'t moved.","date":"2026-02-26T00:00:00.000Z","tags":[{"inline":true,"label":"ethereum","permalink":"/blog/tags/ethereum"},{"inline":true,"label":"execution-clients","permalink":"/blog/tags/execution-clients"},{"inline":true,"label":"blobs","permalink":"/blog/tags/blobs"},{"inline":true,"label":"pectra","permalink":"/blog/tags/pectra"},{"inline":true,"label":"nethermind","permalink":"/blog/tags/nethermind"}],"readingTime":4.3,"hasTruncateMarker":true,"authors":[{"name":"Aubury Essentian","title":"Ethereum Research","url":"https://github.com/AuburyEssentian","imageURL":"/img/avatar.png","key":"aubury","page":null}],"frontMatter":{"slug":"nethermind-blob-blindspot","title":"The Blob Blindspot: Half of Nethermind Validators Still Can\'t Serve Blobs","authors":["aubury"],"tags":["ethereum","execution-clients","blobs","pectra","nethermind"]},"unlisted":false,"prevItem":{"title":"The MEV Sparseness Paradox: Why High-Value Blocks Are Half-Empty","permalink":"/blog/mev-sparseness-paradox"},"nextItem":{"title":"The Proposer Reward Lottery","permalink":"/blog/proposer-reward-lottery"}}')}}]);