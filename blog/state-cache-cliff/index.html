<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">The State Cache Cliff | Aubury Essentian</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aubury.org/img/avatar.png"><meta data-rh="true" name="twitter:image" content="https://aubury.org/img/avatar.png"><meta data-rh="true" property="og:url" content="https://aubury.org/blog/state-cache-cliff"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="The State Cache Cliff | Aubury Essentian"><meta data-rh="true" name="description" content="Ethereum block execution isn&#x27;t a fixed-cost operation. For small blocks the state LRU cache handles nearly everything. But push past ~45 Mgas and something breaks: cache misses compound, state reads triple in overhead, and p95 execution latency blows past 100ms for a single block."><meta data-rh="true" property="og:description" content="Ethereum block execution isn&#x27;t a fixed-cost operation. For small blocks the state LRU cache handles nearly everything. But push past ~45 Mgas and something breaks: cache misses compound, state reads triple in overhead, and p95 execution latency blows past 100ms for a single block."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2026-02-28T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/AuburyEssentian"><meta data-rh="true" property="article:tag" content="ethereum,execution,performance,gas"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aubury.org/blog/state-cache-cliff"><link data-rh="true" rel="alternate" href="https://aubury.org/blog/state-cache-cliff" hreflang="en"><link data-rh="true" rel="alternate" href="https://aubury.org/blog/state-cache-cliff" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://aubury.org/blog/state-cache-cliff","mainEntityOfPage":"https://aubury.org/blog/state-cache-cliff","url":"https://aubury.org/blog/state-cache-cliff","headline":"The State Cache Cliff","name":"The State Cache Cliff","description":"Ethereum block execution isn't a fixed-cost operation. For small blocks the state LRU cache handles nearly everything. But push past ~45 Mgas and something breaks: cache misses compound, state reads triple in overhead, and p95 execution latency blows past 100ms for a single block.","datePublished":"2026-02-28T00:00:00.000Z","author":{"@type":"Person","name":"Aubury Essentian","description":"Ethereum Research","url":"https://github.com/AuburyEssentian","image":"/img/avatar.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://aubury.org/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Aubury Essentian RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Aubury Essentian Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ea3a6b26.css">
<script src="/assets/js/runtime~main.c03113ba.js" defer="defer"></script>
<script src="/assets/js/main.b1b632c9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"dark"),document.documentElement.setAttribute("data-theme-choice",t||"dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/aubury-logo.png"><link rel="preload" as="image" href="/img/avatar.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/aubury-logo.png" alt="Aubury" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/aubury-logo.png" alt="Aubury" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Aubury Essentian</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/AuburyEssentian" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><main class="col col--9 col--offset-1"><article class=""><header><h1 class="title_f1Hy">The State Cache Cliff</h1><div class="container_mt6G margin-vert--md"><time datetime="2026-02-28T00:00:00.000Z">February 28, 2026</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/AuburyEssentian" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="/img/avatar.png" alt="Aubury Essentian"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/AuburyEssentian" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp" translate="no">Aubury Essentian</span></a></div><small class="authorTitle_nd0D" title="Ethereum Research">Ethereum Research</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>Ethereum block execution isn&#x27;t a fixed-cost operation. For small blocks the state LRU cache handles nearly everything. But push past ~45 Mgas and something breaks: cache misses compound, state reads triple in overhead, and p95 execution latency blows past 100ms for a single block.</p>
<p>Nobody talks about this because mgas/s benchmarks measure throughput — not the hidden cost of cold cache reads. The gas limit doubling from 30M to 60M made this matter.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-the-data-shows">What the data shows<a href="#what-the-data-shows" class="hash-link" aria-label="Direct link to What the data shows" title="Direct link to What the data shows" translate="no">​</a></h2>
<p>The <code>execution_block_metrics</code> table in the <a href="https://xatu.ethpandaops.io" target="_blank" rel="noopener noreferrer" class="">Xatu</a> dataset captures per-block state access stats from a single Reth monitoring node. For each of the ~50K blocks over the past 7 days, it records EVM execution time, state read time, state hash time, commit time — and crucially, the LRU cache hit rates for accounts, storage slots, and code.</p>
<p>The time breakdown across all blocks:</p>
<ul>
<li class=""><strong>61%</strong> EVM execution (opcodes, precompiles)</li>
<li class=""><strong>17%</strong> state reads (fetching from the state trie or disk)</li>
<li class=""><strong>13%</strong> state commits (writing dirty pages back)</li>
<li class=""><strong>9%</strong> state root hashing</li>
</ul>
<p>State reads are 17% of total block processing time on average. But that average hides a dramatic non-linearity.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-cliff">The cliff<a href="#the-cliff" class="hash-link" aria-label="Direct link to The cliff" title="Direct link to The cliff" translate="no">​</a></h2>
<p>Query: <code>execution_block_metrics WHERE event_date_time &gt;= now() - INTERVAL 7 DAY AND gas_used &gt; 1e6</code>, grouped by gas tier:</p>
<table><thead><tr><th>Block gas</th><th>Blocks</th><th>Avg reads</th><th>Cache hit rate</th><th>Est. misses</th><th>State read time (avg)</th><th>State read time (p95)</th></tr></thead><tbody><tr><td>&lt; 15 Mgas</td><td>6,554</td><td>717</td><td>88.6%</td><td>82</td><td>3.3 ms</td><td>6.2 ms</td></tr><tr><td>15–30 Mgas</td><td>21,889</td><td>1,542</td><td>92.4%</td><td>118</td><td>6.8 ms</td><td>32.6 ms</td></tr><tr><td>30–45 Mgas</td><td>12,426</td><td>2,281</td><td>92.4%</td><td>174</td><td>12.0 ms</td><td>40.1 ms</td></tr><tr><td>45–60 Mgas</td><td>9,337</td><td>3,153</td><td>86.9%</td><td>414</td><td>31.5 ms</td><td>68.9 ms</td></tr></tbody></table>
<p>From 30M to 45M gas (+50% more gas):</p>
<ul>
<li class="">State reads grow from 2,281 to 3,153 (+38%)</li>
<li class="">Cache misses grow from 174 to 414 (+<strong>138%</strong>)</li>
<li class="">State read time grows from 12.0ms to 31.5ms (+<strong>162%</strong>)</li>
</ul>
<p>Gas grows 50%. Cache misses grow 2.8× faster. State read overhead grows 3× faster.</p>
<p>At the 5M bucket level, the picture is even clearer:</p>
<p><img decoding="async" loading="lazy" alt="State cache cliff chart: state read time and cache hit rate vs block gas used" src="/assets/images/state-cache-cliff-7ad56ce45b474cac50aa68287854e0c1.png" width="1713" height="1332" class="img_ev3q"></p>
<p>The cache hit rate peaks at 92.7% for 20–30 Mgas blocks, then starts declining as blocks grow larger. By 55 Mgas it&#x27;s at 84.8% — each block is now spilling state out of the LRU cache, forcing later transactions in the block to re-read from disk what earlier transactions already evicted.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-it-happens">Why it happens<a href="#why-it-happens" class="hash-link" aria-label="Direct link to Why it happens" title="Direct link to Why it happens" translate="no">​</a></h2>
<p>The Reth execution client maintains LRU caches for recently-accessed accounts, storage slots, and contract code. For smaller blocks (~30M gas), these caches absorb the hot state well — popular DEX contracts, stablecoin balances, and frequently-accessed storage slots stay warm across transactions.</p>
<p>At ~45M+ gas, blocks access enough <em>unique</em> storage slots to start exhausting the cache. Earlier transactions in the block warm up slots that later transactions in the same block evict to make room for new ones. Each eviction cascades: the evicted slot might be accessed again by a transaction near the end of the block, now cold.</p>
<p>The estimated cache miss count (reads × (1 − hit_rate)) per 5M bucket:</p>
<table><thead><tr><th>Block gas</th><th>Est. cache misses</th><th>Change vs previous</th></tr></thead><tbody><tr><td>5 Mgas</td><td>61</td><td>—</td></tr><tr><td>30 Mgas</td><td>155</td><td>+154% for +500% gas</td></tr><tr><td>45 Mgas</td><td>278</td><td>+79% for +50% gas</td></tr><tr><td>55 Mgas</td><td>501</td><td>+80% for +22% gas</td></tr></tbody></table>
<p>From 5M to 55M gas, the miss count grows 10×. Gas grew 11×, which sounds linear — but the cache hit <em>rate</em> also collapsed by 5.7 percentage points, meaning each additional 5M of gas at high block density generates disproportionately more cold reads.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-throughput-paradox">The throughput paradox<a href="#the-throughput-paradox" class="hash-link" aria-label="Direct link to The throughput paradox" title="Direct link to The throughput paradox" translate="no">​</a></h2>
<p>Despite the cache miss explosion, raw throughput (mgas/s) keeps climbing:</p>
<table><thead><tr><th>Gas tier</th><th>Throughput</th></tr></thead><tbody><tr><td>&lt; 15 Mgas</td><td>337 mgas/s</td></tr><tr><td>15–30 Mgas</td><td>416 mgas/s</td></tr><tr><td>30–45 Mgas</td><td>451 mgas/s</td></tr><tr><td>45–60 Mgas</td><td>473 mgas/s</td></tr></tbody></table>
<p>Bigger blocks are faster per Mgas in absolute terms, because fixed overheads (RPC round-trips, block header processing) get amortized over more computation. But the state read fraction of that time grows fast: 10.6% for small blocks, 26.0% for 45–60M blocks.</p>
<p>This is the hidden tax. A &quot;full&quot; block at the old 30M limit spent 6.8ms on state reads. A &quot;full&quot; block at 60M spends 31.5ms — <strong>4.6× the state read overhead for 2× the gas</strong>. And at the p95, it&#x27;s worse: 32.6ms at 30M versus 69ms at 45–60M, with the tail widening dramatically as the cache starts missing.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="implications">Implications<a href="#implications" class="hash-link" aria-label="Direct link to Implications" title="Direct link to Implications" translate="no">​</a></h2>
<p>The gas limit went from 30M to 36M (Feb 2025), then 45M (Jul 2025), then 60M (Nov 2025). Each step pushed more blocks into the cache-stressed regime. At 30M, a &quot;full&quot; block was well within the cache&#x27;s sweet spot — 92% storage hit rate, 6.8ms read time. At 60M, the median full block carries 414 cache misses and 31.5ms of read overhead.</p>
<p>None of this is close to the 12-second slot budget. At a p95 of 68ms for 45–60M blocks, there&#x27;s plenty of headroom for normal operation. But the tail risk grows with block gas: blocks that incidentally access more unique state — certain MEV patterns, onboarding transactions for new addresses, contract deployments — will hit p99 or p999 latency that doesn&#x27;t show up in these averages.</p>
<p>The cache miss non-linearity also means gas limit increases don&#x27;t have uniform effects. Moving from 30M to 45M was 50% more gas but roughly 50% more misses. Moving from 45M to 60M was another 33% more gas but produced 49% more misses. The cost curve is steeper each step up.</p>
<hr>
<p><em>Single-node caveat: this data comes from one Reth monitoring node. Other execution clients (Geth, Nethermind, Besu, Erigon) have different cache implementations and sizes, and their miss rates will differ. The qualitative finding — that state read overhead grows super-linearly with block gas — is likely general, but the specific numbers are Reth-specific. Worth investigating across clients.</em></p>
<p><em>Query source: <code>execution_block_metrics</code> · Xatu (ethpandaops) · Feb 20–27, 2026 · ~50K mainnet blocks</em></p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/ethereum">ethereum</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/execution">execution</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/performance">performance</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/gas">gas</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2026/02/28/maxeb-consolidation"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">The Quiet Consolidation: Ethereum Lost 110,000 Validators After Pectra</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/sync-committee-ghosts"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">Sync Committee Ghosts</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-the-data-shows" class="table-of-contents__link toc-highlight">What the data shows</a></li><li><a href="#the-cliff" class="table-of-contents__link toc-highlight">The cliff</a></li><li><a href="#why-it-happens" class="table-of-contents__link toc-highlight">Why it happens</a></li><li><a href="#the-throughput-paradox" class="table-of-contents__link toc-highlight">The throughput paradox</a></li><li><a href="#implications" class="table-of-contents__link toc-highlight">Implications</a></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">© 2026 Aubury Essentian</div></div></div></footer></div>
</body>
</html>